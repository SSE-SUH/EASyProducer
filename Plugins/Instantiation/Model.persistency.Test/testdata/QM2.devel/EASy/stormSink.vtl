template stormSink(Configuration config, FileArtifact target, DecisionVariable preElt, DecisionVariable elt, String topoName) {

    def main(Configuration config, FileArtifact target, DecisionVariable preElt, DecisionVariable elt, String topoName) {
        String name = elt.varName().firstToUpperCase() + elt.type();
        String preIfName = "I" + preElt.byName("family").varName().firstToUpperCase();
		String preOutputName= "I" + preIfName + "Output";
        'package eu.qualiMaster.topologies.$topoName;'
    	''
    	'import java.util.*;'
    	'import org.apache.log4j.Logger;'
    	'import backtype.storm.tuple.*;'
    	'import backtype.storm.task.*;'
    	'import backtype.storm.topology.*;'
    	'import eu.qualiMaster.signal.*;'
    	'import eu.qualiMaster.families.inf.$preIfName.$preOutputName;'
    	''
    	'@SuppressWarnings({ "rawtypes", "serial" })'
    	'public class $name extends BaseSignalBolt {'
    	''
    	'    final static Logger logger = Logger.getLogger($name.class);'
    	'    OutputCollector _collector;'
    	''
    	'	public $name(String name) {'
    	'        super(name);'
    	'   }'
		'    @Override'
		'    public void execute(Tuple tuple) {'
		'        //for now, sink just emits the tuple that get from last familyelement'
		'        $preOutputName iTuple = ($preOutputName) tuple.getValue(0); '
		'        logger.info("Emitting data from Sink:" + iTuple);'
		'        _collector.emit(tuple, new Values(iTuple));'
		'        _collector.ack(tuple);'
		'    }'
	    ''
		'    @Override'
		'    public void prepare(Map map, TopologyContext topologyContext, OutputCollector collector) {'
		'        _collector = collector;'
		'    }'
	    ''
		'    @Override'
		'    public void declareOutputFields(OutputFieldsDeclarer declarer) {'
		'        declarer.declare(new Fields("sinkData"));'
		'    }'
    	''
    	'    @Override'
	    '    public void onSignal(byte[] data) {'		
	    '    }'
    	'}'
    }
    
}