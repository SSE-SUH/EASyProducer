@advice(QM)
template familyInterfaceJava(Configuration config, FileArtifact target, DecisionVariable family, String ifName) {

    // needs to be translated into new advice-style of writing

    def String parameterTypeName(DecisionVariable var) {
    	switch(var.type()) {
    		"IntegerParameter" : "int",
    		"BooleanParameter" : "boolean",
    		"RealParameter" : "double",
    		"StringParameter" : "String"
    	}
    }
    
    def String fieldTypeName(DecisionVariable var) {
    	String type = var.byName("type");
    	/* 
    	switch(type) {
    		"INTEGER" : "int",
    		"BOOLEAN" : "boolean",
    		"REAL" : "double",
    		"STRING" : "String"
    	}
    	* */
    	if(type == "INTEGER") {
    	    "int";
    	}else if(type == "BOOLEAN"){
    		"boolean";
    	}else if(type == "REAL") {
    		"double";
    	}else {
    		"String";
    	}
    }
    
    def String produceForTuples(DecisionVariable tuples, Boolean output, Boolean implementation, String ifName, Integer indent) {
	    String type;
	    String typeName;
    	if (output) {
    		type = "${ifName}Output";
    		typeName = "output";
    	} else {
    		type = "${ifName}Input";
    		typeName = "input";
    	}
    	String langElt;
    	String implements;
    	if (implementation) {
    		langElt = "class";
    		implements = "implements ${ifName}.I${type} ";
    	} else {
    		type = "I" + type;
    		langElt = "interface";
    		implements = "";
    	}
		'/**' | indent;
    	if (implementation) {
        	'* Provides a default implementation of the data ${typeName} for the {@link ${type}} algorithm.' | indent + 1;
        	'* Actual execution system code may also directly wrap the respective tuple concept.' | indent + 1;
    	} else {
    		'* Defines the data ${typeName} interface for the {@link ${type}} algorithm (over all defined ${typeName} tuples).' | indent + 1;
    	}
		'*/' | indent + 1;
    	'public $langElt $type ${implements}{' | indent;
    	''
    	
    	// if implementation, produce attributes first
    	Integer tuplesSize = tuples.variables().size();
    	String tupleId;
    	Integer tupleCount = 1;
    	if (implementation) {
    		for (Tuple t : tuples) {      
	    		String tupleId = "";
	    		if (tuplesSize > 1) {
	    			tupleId = "Tuple${tupleCount}"; // we need an operator
	    		}
    			for (Field f : t.fields()) {
    				String fname = toIdentifier("${tupleId}${f.name()}");
    				String ftype = fieldTypeName(f);
    				'private ${ftype} ${fname}' | indent + 4;
    			}
    		}
    		tupleCount = tupleCount + 1;
    		''
    	}
    	
    	// and now the signatures / implementations
		String signatureEnd;
		if (implementation) {
			signatureEnd = " {";
		} else {
			signatureEnd = ";";
		}
		tupleCount = 1;
    	for (Tuple t : tuples) {
    		String tupleId = "";
    		if (tuplesSize > 1) {
    			tupleId = "Tuple${tupleCount}"; // we need an operator
    		}
    		for (Field f : t.fields()) {
    			String fname = toIdentifier("${tupleId}${f.name()}");
    			String mname = firstToUpperCase(fname);
    			String ftype = fieldTypeName(f);
	
					if (implementation) {
						'@Override' | indent + 4;
					} else {
						'/**' | indent + 4;
						'* Returns the input value for tuple field "${f.name()}".' | indent + 5;
						'* @return the tuple value' | indent + 5;
						'*/' | indent + 5;
					}
	    			'public ${ftype} get${mname}()${signatureEnd}' | indent + 4;
	    			if (implementation) {
	    				'return ${fname};' | indent + 8;
	    				'}' | indent + 4;
	    			}
	    			''
			
			
					if (implementation) {
						'@Override' | indent + 4;
					} else {
						'/**' | indent + 4;
						'* Changes the output value for tuple field "${f.name()}".' | indent + 5;
						'* @param ${fname} the field value' | indent + 5;
						'*/' | indent + 5;
					}
	    			'public void set${mname}(${ftype} ${fname})${signatureEnd}' | indent + 4;
	    			if (implementation) {
	    				'this.${fname} = ${fname};' | indent + 8;
	    				'}' | indent + 4;
	    			}
				
    		}
    		tupleCount = tupleCount + 1;
    	}
    	'}' | indent;
    	''
    	type;
    }

    def main(Configuration config, FileArtifact target, DecisionVariable family, String ifName) {
    	'package eu.qualiMaster.families.inf;'
    	''
    	//produceForTuples(family.byName("input"), false, true, ifName, 0);
    	//produceForTuples(family.byName("output"), true, true, ifName, 0);
    	''
    	'/**'
    	' * Defines the interface for the algorithm family "${ifName}".'
    	' */'
    	'public interface ${toIdentifier(ifName)} {'
    	''
    	String inTypeName = produceForTuples(family.byName("input"), false, false, ifName, 4);
    	String outTypeName = produceForTuples(family.byName("output"), true, false, ifName, 4);
    	'    /**'
    	'     * Calculates the actual <code>result</code> for <code>input</code>.'
    	'     *'
    	'     * @param input the algorithm input taken from the input stream'
    	'     * @param result the result calculated by the algorithm'
    	'     */'
        '    public void calculate(${inTypeName} input, ${outTypeName} result);'
        ''
        if (family.byName("parameters").variables().size()>0) {
	        '    // algorithm parameters'
	        ''
	        for (Parameter p : family.byName("parameters")) {
	        	String paramName = p.name();
    			String mname = firstToUpperCase(toIdentifier(paramName));
	        	'    /**'
	        	'     * Sets the algorithm parameter "${paramName}".'
	        	'     *'
	        	'     * @param value the new value of the algorithm parameter'
	        	'     */'
	        	'    public void setParameter${mname}(${parameterTypeName(p)} value);'
	        	''
	    	}
    	}
    	'}'
    }
    
}